/*
 * Copyright 2019, The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.example.android.productivity.productivitytracker

import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.WindowManager
import androidx.appcompat.app.AppCompatActivity
import androidx.databinding.DataBindingUtil
import androidx.fragment.app.Fragment
import androidx.lifecycle.Observer
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import androidx.navigation.fragment.navArgs
import androidx.recyclerview.widget.LinearLayoutManager
import com.example.android.productivity.Adapters.CustomAdapter
import com.example.android.productivity.R
import com.example.android.productivity.database.ProductiveDay
import com.example.android.productivity.database.ProductivityDatabase
import com.example.android.productivity.database.ProductivityDatabaseDao
import com.example.android.productivity.databinding.FragmentProductivityTrackerBinding
import com.example.android.productivity.viewmodelFactories.ProductivityTrackerViewModelFactory
import com.example.android.productivity.viewmodels.ProductivityTrackerViewModel
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import java.util.*


/**
 * A fragment with buttons to record start and end times for sleep, which are saved in
 * a database. Cumulative data is displayed in a simple scrollable TextView.
 * (Because we have not learned about RecyclerView yet.)
 * The Clear button will clear all data from the database.
 */
class ProductivityTrackerFragment : Fragment() {

    /**
     * Called when the Fragment is ready to display content to the screen.
     *
     * This function uses DataBindingUtil to inflate R.layout.fragment_sleep_quality.
     *
     * It is also responsible for passing the [ProductivityTrackerViewModel] to the
     * [FragmentSleepTrackerBinding] generated by DataBinding. This will allow DataBinding
     * to use the [LiveData] on our ViewModel.
     */

    val args: ProductivityTrackerFragmentArgs by navArgs()
    var receivedName = "-1"
    var receivedSleepInt = -1
    var receivedWakeUpInt = -1

    var prefs: SharedPreferences? = null
    var sharedPreferencesEditor: SharedPreferences.Editor? = null

    lateinit var arrayOfDays: List<ProductiveDay>

    val NAME_KEY = "Name"
    val SLEEP_KEY_HOUR = "Sleep Time Hour"
    val SLEEP_KEY_MINUTE = "Sleep Time Minute"
    val WAKE_KEY_HOUR = "Wake up Hour"
    val WAKE_KEY_MINUTE = "Wake up Minute"

    val LOG_TAG = "ProdTrackFrag"
    val NAVIGATE_TO_ADD = "go to add activity"
    val MSG_RATEGOAL = "Rate Goal"

    val FIRST_TIME_USER = "first time"
    var rateDayFromMainFrag = ""

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {

        // Get a reference to the binding object and inflate the fragment views.
        val binding: FragmentProductivityTrackerBinding = DataBindingUtil.inflate(
                inflater, R.layout.fragment_productivity_tracker, container, false)

        val application = requireNotNull(this.activity).application

        // Create an instance of database the ViewModel Factory.
        val dataSource = ProductivityDatabase.getInstance(application).productivityDatabaseDao
        val viewModelFactory = ProductivityTrackerViewModelFactory(dataSource, application)

        // Get a reference to the ViewModel associated with this fragment.
        val productivityTrackerViewModel =
                ViewModelProvider(
                        this, viewModelFactory).get(ProductivityTrackerViewModel::class.java)

        // To use the View Model with data binding, you have to explicitly
        // give the binding object a reference to it.
        binding.productivityTrackerViewModel = productivityTrackerViewModel

        // Specify the current activity as the lifecycle owner of the binding.
        // This is necessary so that the binding can observe LiveData updates.
        binding.lifecycleOwner = this

        prefs = requireContext().getSharedPreferences(
            getString(R.string.app_name), Context.MODE_PRIVATE
        )
        sharedPreferencesEditor = prefs?.edit()

        try {
            //this is to deny notifications when user goes to mainactivity first time visiting app
            sharedPreferencesEditor?.putBoolean(FIRST_TIME_USER, false)?.apply()

            //initialise data for RV
            getDataForRV(productivityTrackerViewModel, dataSource, binding)

            //setup recyclerview after getting data from db
            productivityTrackerViewModel.eventGotDataToFillRV.observe(viewLifecycleOwner, Observer {
                if (it == true){
                    fillRVData(binding)
                }
            })
        } catch (e:Exception){
            e.printStackTrace()
        }

        //TODO: activate this function, its stopped for testing only
        hideOrShowFab(dataSource, binding)

        //get if today exists or not to know what to do when fab is clicked
        val todayExists = doesTodayExistInDB(dataSource)

        //set action of fab to go to add new task fragment
        binding.fab.setOnClickListener{
            navigateToAddGoalActivity(productivityTrackerViewModel, todayExists)
        }

        return binding.root
    }


    private fun navigateToAddGoalActivity(productivityTrackerViewModel: ProductivityTrackerViewModel, msg : String) {
        productivityTrackerViewModel.NavToAddGoalFragment()
        val intent = Intent(requireContext(), AddGoal::class.java)

        //this extra will let us display add UI and functionality instead of update
        intent.putExtra("Add", msg)
        intent.putExtra("NotificationMessage", "")
        intent.flags =
            Intent.FLAG_ACTIVITY_NEW_TASK or
                    Intent.FLAG_ACTIVITY_CLEAR_TASK or
                    Intent.FLAG_ACTIVITY_CLEAR_TOP

        Log.e(LOG_TAG, msg)

        requireContext().startActivity(intent)
        activity?.finish()
    }

    private fun doesTodayExistInDB(dataSource : ProductivityDatabaseDao) : String {
        //check if goal already exists for today to hide the add new goal screen
        val todayExists = runBlocking { checkIfGoalExistsForDay(dataSource) }
        return if (todayExists){
            MSG_RATEGOAL
        } else {
            NAVIGATE_TO_ADD
        }
    }

    private fun fillRVData(binding: FragmentProductivityTrackerBinding) {
        val recyclerview = binding.recyvlerView

        // this creates a vertical layout Manager
        recyclerview.layoutManager = LinearLayoutManager(requireContext())

        // This will pass the ArrayList to our Adapter
        val adapter = CustomAdapter(arrayOfDays)

        // Setting the Adapter with the recyclerview
        recyclerview.adapter = adapter

        adapter.notifyDataSetChanged()

    }

    private fun getDataForRV(productivityTrackerViewModel : ProductivityTrackerViewModel,
                             dataSource: ProductivityDatabaseDao, binding: FragmentProductivityTrackerBinding) {
        //get the data from db to fill rv
        viewLifecycleOwner.lifecycleScope.launch {
            val dataArray = dataSource.getAllDays()
            arrayOfDays = dataArray

            //show the empty icon
            if(arrayOfDays.isEmpty()){
                binding.relateiveLayoutForAddFirstItemImage.visibility = View.VISIBLE
                binding.firstGoalDoesntExist.visibility = View.VISIBLE
                binding.firstItemImg.visibility = View.VISIBLE
            } else {
                binding.relateiveLayoutForAddFirstItemImage.visibility = View.GONE
                binding.firstGoalDoesntExist.visibility = View.GONE
                binding.firstItemImg.visibility = View.GONE

            }
            productivityTrackerViewModel.doneGettingDataForRV()

        }
    }

    private fun hideOrShowFab(dataSource : ProductivityDatabaseDao, binding :  FragmentProductivityTrackerBinding) {
        //check if goal already exists for today to hide the add new goal screen
        val todayExists = runBlocking { checkIfGoalExistsForDay(dataSource) }
        if (todayExists){
            binding.fab.visibility = View.GONE
        } else {
            binding.fab.visibility = View.VISIBLE
        }
    }



    private suspend fun checkIfGoalExistsForDay(db : ProductivityDatabaseDao) : Boolean {

        //check if today exists
        val calender = Calendar.getInstance()
        val day = calender.get(Calendar.DAY_OF_YEAR)
        val year = calender.get(Calendar.YEAR)
        val dayInYear = "$day + $year"

        //get arguments from database to check if today's goal exists
        val dayFromDb = db.getDayInYear("$day + $year")?.day

        return dayFromDb == dayInYear
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        //show custom action bar
        (requireActivity() as AppCompatActivity).supportActionBar?.show()

        //show full screen
        requireActivity().window.addFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS)

    }

    override fun onDetach() {
        super.onDetach()
        //disable full screen
        requireActivity().window.clearFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS)

    }




    }


